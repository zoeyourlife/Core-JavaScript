# 1장 데이터 타입

## 1. 기본형-참조형 데이터 타입간 차이는?

### 불변 값? 가변 값? 불변 객체?

- **한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지**의 여부로 변수와 상수를 구분짓는다.

- 반대로 불변성 여부를 판단할 때에는, **데이터 영역의 메모리**를 대상으로 판별한다.

- 기본형 데이터는, 전부 불변값이다.

  - 변수 a에 문자열 데이터 hi를 할당한 뒤, 변수 b에 문자열 데이터를 할당할 때는 데이터 영역에서 hi를 먼저 찾은 후, 있다면 데이터가 있는 데이터 영역의 주소값을 활용하고, 없으면 데이터 영역 내 빈 공간에 새로 만들어 그 주소값을 사용한다.
  - 이 때문에, 한 번 만들어놓은 값을 변경할 수가 없다. 변경된다면, 새롭게 만들어지는 과정을 통해서만 가능하다! 이것이 불변값의 성질이다.

  ```javascript
  var a = 'hi';
  var b = 'hi';
  ```



- 기본형 데이터는 전부 불변값.. 그렇다면 참조형 데이터는 반드시 가변값일까?

  - 기본적인 성질은 가변값이지만, 경우에 따라 불변값으로 활용하기도 한다.

  - 기본형 데이터와의 차이는 메모리 공간 내 **객체의 프로퍼티 영역**이 별도로 존재한다는 점이다!

    - 객체가 별도로 할애하는 영역은 변수 영역일 뿐, 해당 변수에 할당되는 데이터는 기존 데이터 영역의 공간을 그대로 사용하며 변수에는 다른 값을 얼마든지 대입할 수 있다.

    - **데이터 영역에 저장된 값은 모두 불변값이다!**

    - 객체의 프로퍼티의 값을 바꾸더라도, 새 객체가 만들어지는게 아니라 **기존 객체 내부의 값만 바뀐다.**

      - 이럴 때, 참조형 데이터는 가변값이다.

    - 객체의 프로퍼티에 다른 참조형 데이터를 할당하면 메모리 공간 내 객체의 프로퍼티 영역이 새롭게 생기게 되겠지만,  데이터 영역에서 주소값을 찾는 과정은 동일하다.

      

### 변수 복사 / 값(프로퍼티) 변경시 어떤 차이가 있을까?

- 기본형 / 참조형 모두 변수 선언 및 데이터 할당 이후, 새로운 변수를 선언한 뒤 복사를 하고 나면 두 변수가 같은 데이터 영역의 주소를 바라보게 된다는 점은 동일하다.

- 다만 이렇게 복사한 변수에 할당된 값(혹은 프로퍼티의 값)을 변경하게 되면, 차이가 생긴다!

  ```javascript
  var a = 'hi';
  var b = a;
  
  var obj = {
      c: 'bbb'
  };
  var obj2 = obj
  
  b = 'bye';
  obj2.c = 'ccc'
  ```

  - 기본형 데이터를 복사한 변수에 할당된 값을 바꾸면, 참조하는 메모리 공간의 주소값이 변경된다.
  - 반대로 참조형 데이터를 복사한 변수는 프로퍼티 값을 변경하더라도, 변수에 할당된 프로퍼티 영역의 주소값은 변경되지 않는다!
    - 변수에 할당한 참조형 데이터 자체를 변경하는게 아니라면, 주소값이 변경되지 않는다. 

### 얕은 복사? 깊은 복사?

- 얕은 복사는 바로 아래 단계의 값만 복사한다.
  - 참조형 데이터가 저장된 프로퍼티를 복사할 때, **주소값만** 복사한다는 의미이다!
  - 당연히 원본과 사본이 전부 같은 주소를 바라보게 되고, 한 쪽에서 프로퍼티의 값이 변경되면 다른 쪽에도 영향을 미친다. 같은 주소를 바라보기 때문이다.
  - 기본형 데이터라면 그냥 복사하면 되겠지만 참조형 데이터라면, 얕은 복사로는 프로퍼티의 값 변경시 의도치 않게 같은 주소를 바라보는 다른 참조형 데이터에서도 해당 값이 변경되는 문제가 발생하곤 한다.
- 깊은 복사는 내부의 모든 값들을 전부 복사한다.
  - 따라서 참조형 데이터라면, 내부의 프로퍼티들을 재귀적인 과정을 통해 전부 복사하는 깊은 복사가 필요하다!

## 2. 변수에 데이터를 할당하는 과정은 어떻게 이루어지는가?

- 변수: 변경 가능한 데이터가 담길 수 있는 공간
- 식별자: 특정 데이터를 식별하는 데 사용하는 이름 -> 변수명

### 변수 영역, 메모리 영역에 값이 생성되고, 값을 참조하는 과정은?

```javascript
var grade = 100;
```

- 변수 grade를 선언하고, a에 100이라는 데이터를 할당한다.
  - 변수 grade를 메모리에 할당하기 위해, 메모리 영역에서 비어있는 공간을 확보한다.
  - 이 공간의 이름 (식별자)을 grade라고 부른다.
  - 메모리 공간 내 grade라는 이름(식별자)를 가진 영역이 아닌, **별도의 메모리 공간**을 다시 확보해 100이라는 값을 저장한다.
  - 데이터 영역 내에서 저장한 100의 주소를 변수 영역에서 grade라는 식별자를 가지는 주소에 대입한다.
- 왜 별도의 데이터 영역에 값을 저장하는가?
  - 미리 확보한 공간 안에서만 데이터 변환이 가능하다면, 변환된 데이터를 다시 저장하는 과정에서 변환된 데이터의 크기에 맞게 공간을 늘리는 작업이 필요할 수 있다.
  - 경우에 따라 기존 확보되었던 데이터 영역에서 변환된 데이터의 크기에 맞게 늘어난 공간에 다른 데이터가 저장되어 있을 수 있고, 이 경우 해당 공간에 저장되어 있던 데이터들을 필요한 공간만큼 뒤로 밀어내야 한다.
  - 이로 인해 처리해야 하는 연산이 많아지게 되기 때문에 **변수와 데이터를 데이터 영역 내에서 별도의 공간으로 나누어 저장**함

```javascript
var grade = 101;
```

- 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당할 때, 기존 데이터 영역에 할당되어 있던 주소를 재활용하는가?
  - 앞서 데이터 영역 내에 100이 저장되어 있던 공간에 101을 할당하는 대신, 101이라는 값을 **별도의 공간에 저장한다.** 

## 3. undefined와 null의 차이점은? 

- 같은 듯 다른 둘
  - `undefined`와 `null`은 둘 다 **없음** 을 나타내지만, 사용하고자 하는 목적에서 차이가 있다.
- `undefined`
  - 사용자가 명시적으로 지정하기도 하지만, 값이 존재하지 않을 때 JS 엔진이 자동으로 부여하기도 함
  - JS 엔진은 어떻게 자동으로 undefined 값을 부여할까?
    - 엔진은, 사용자가 어떠한 값을 지정할 것이라고 예상되는 상황에서 실제로 그렇게 하지 않았을 때 undefined를 반환한다.
      - 값을 대입하지 않은 변수에 접근할 때
      - 객체 내부의 존재하지 않는 프로퍼티에 접근하려 할 때
        - 존재하지 않는 프로퍼티에 대해서는, 순회할 수 없다
        - 값이 지정되지 않은 인덱스는 아직 존재하지 않는 프로퍼티
      - return문이 없거나, 호출되지 않는 함수의 실행 결과
  - undefined는 비어있음을 의미하지만, 하나의 값으로 동작
    - 값으로서 어딘가에 할당되었다는 것은, **실존하는 데이터**임을 의미함
    - 사용자가 직접 undefined 값을 할당한 경우, 이 때의 객체 내 프로퍼티나 배열의 요소는 고유한 키값(프로퍼티 이름)이 실존하게 되고, 순회의 대상이 된다.
    - 반면 JS 엔진이 부여한 undefined에는 해당 프로퍼티, 키값이 존재하지 않음
      - 문자 그대로 값이 없음을 나타냄



- `null`
  
  https://velog.velcdn.com/images/zeppel1n/post/9d06a9e7-f955-4f3e-b2e5-f29a7ad85d47/image.png
  
  - '비어있음'을 **명시적으로 나타내고 싶을 때**는 null을 사용한다.
  - 단 주의할 점은, `typeof` 연산자를 통해 typeof null 같이 진행하는 경우, `object`가 반환된다는 것
    - 따라서 어떤 변수의 값이 null인지 판별하려면, 일치 연산자(===)를 사용해 특정 변수가 실제로 null인지 판별할 수 있다.
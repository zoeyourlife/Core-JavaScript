# 코어 자바스크립트 Note

## 02. 실행 컨텍스트

## 02-1. 실행 컨텍스트란?

실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체.
필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 코드들을 실행하는 식으로 환경과 순서 보장!

자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를
구성하는 방법은 _**함수를**실행하는 것 뿐이다_

실행 컨텍스트와 콜 스택이 어떤 식으로 구성되고 진행되는 지 이해하고 있으면 프로그램의 플로우를 알 수 있다.

- **VariableEnvironment:** 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않는다.

- **LexicalEnvironment**: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.

- **ThisBinding:** this 식별자가 바라봐야 할 대상 객체

## 02-2. VarlableEnvironment?

여기에 담기는 내용은 렉시컬 환경과 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다름

실행 컨텍스트를 생성할 때 VE에 정보를 먼저 담은 다음, 이를 복사하여 LE를 만들고, 이후에는 LE를 주로 활용하게 된다.

## 02-3. LexicalEnvironment?

'사전적인' 환경

### 02-3-1. environmentRecord와 호이스팅

- 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
  컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑으면서 순서대로 수집한다.

> 참고
> 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 JS 구동환경이 별도로 제공하는 객체, 즉 전역 객체를 활용한다.

- 코드가 실행되기 전임에도 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있는데?
- --> 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다!

이것이 바로 호이스팅(hoisting)이라는 개념!

```js
function a() {
  var x = 1;
  console.log(x);
  var x;
  console.log(x);
  var x = 2;
  console.log(x);
}
a();
```

--> 호이스팅을 마친 상태

```js
function a() {
  var x; // 1
  var x;
  var x;

  x = 1; // 6
  console.log(x);
  console.log(x);
  x = 2;
  console.log(x);
}
a(1);
```

2.변수 x 선언 -> 확보한 공간의 주솟값을 변수 x에 연결!

3, 4. 변수 x 다시 선언. 무시하낟.

6. x에 1을 할당 ->> 주솟값 연결

7, 8. 각 x를 출력 둘다 1이 출력

9. x에 2를 할당, 2의 주솟값으로 대치됨

10. 2를 출력후, 모든 코드 실행되었으므로 콜스택에서 실행 컨텍스트가 제거된다.

### 함수 선언문과 함수 표현식 !

> 이 부분을 공부하면서 새로 알게됨. 그동안 무지했다는 것을 깨달음

```js
function a() {
  /*...*/
} // 함수 선언문. 함수명 a가 곧 변수명.
a(); // 실행 OK

var b = function () {
  /* ... */
}; // (익명) 함수 표현식 변수명 b가 곧 함수명.
b(); // 실행 OK

var c = function d() {
  /* ... */
}; // 기명 함수 표현식. 변수명은 c, 함수명은 d.
c(); // 실행 OK
d(); // Error!
```

> 참고
> 기명 함수 표현식은 외부에서 함수명으로 함수를 호출할 수 없다. 함수 내부에서만 접근 가능.
> 이제는 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있다.

#### 함수 선언문과 함수 표현식의 실질적인 차이??

_**함수 선언문은 전체를 호이스팅한다.**_

_**함수 표현식은 변수 선언부만 호이스팅한다.**_

원활한 협업을 위해서는 전역공간에 함수를 선언하거나 동명의 함수를 **중복 선언**하는 경우는 없어야 한다.

하지만 전역공간에 동명의 함수가 여럿 존재하는 상황이라 하더라도 모든 함수가 함수 표현식으로 정의되있다면 괜찮을지도?

### 02-3-2. 스코프, 스코프 체인, outerEnvironmentReference

스코프란? **식별자에 대한 유효범위**이다.

- 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만,
- A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근이 가능하다!
- 전역공간을 제외하면 _오직 함수에 의해서만 스코프가 생성된다_ <ES5한정>

어쨌든! 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라 한다.
이를 가능하게 하는 것이 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.

inner 함수 내부에서 a에 접근하려고 하면 무조건 스코프 체인 상의 첫 번째 인자, 즉 inner 스코프의 LE부터 검색하는데

inner 스코프의 LE에 a 식별자가 존재! 즉 이때 스코프 체인 검색을 더이상 진행하지 않음. 바로 a를 반환한다.

즉, inner 함수 내부에서 a 변수를 선언했기 때문에 전역 공간에 선언한 동일한 이름의 a 변수에는 접근할 수 없는데

이를 바로 **'변수 은닉화'** 라고 한다!

## 04. this

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장된다.
- 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장된다.

## 05. 정리

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체!

- 실행 컨텍스트 객체는 활성화되는 시점에 VariableE, LexicalE, ThisBinding의 세 가지 정보를 수집함

- VE와 LE가 동일한 내용으로 구성되지만, LE는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면, VE는 초기 상태 유지!

- VE와 LE는 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집하는 environmentRecord와 바로 직전 컨텍스트의 LE 정보를 참조하는 outerEnvironment로 구성되있음.

- 호이스팅은 코드 해석을 좀 더 수월하게 하기 위해 수집 과정을 추상화한 개념으로, 끌어올리는 느낌. '선언부'만을.

- 할당 과정은 원래 자리에 남아있게 되는데, 이때 함수 선언문과 함수 표현식의 차이가 발생한다.

- 스코프는 변수의 유효범위를 말하는데, outerEnvironmentReference는 해당 함수가 선언된 위치의 LexicalEnvironment를 참조

- 코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LE를 탐색해서 발견되면 그 값을 반환, 못하면 LE를 탐색하는 과정을 거침

- 전역 컨텍스트의 렉시컬 환경에 담긴 변수를 전역변수라고 하고, 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수들은 모두 지역변수이다.

- 안전한 코드 구성을 위해 전역변수의 사용은 최소화하자!

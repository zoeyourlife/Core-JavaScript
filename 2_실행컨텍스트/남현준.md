# 2장 실행 컨텍스트

## 실행 컨텍스트?

- **실행할 코드에 제공할 환경 정보를 모아놓은 객체**
  - 이를 통해 JS가 동적 언어라는 것을 파악할 수 있다.
  - 동일한 환경에 있는 코드들을 실행할 때, 필요한 환경 정보들을 모아 컨텍스트를 구성
    - 여기서의 동일한 환경, 하나의 실행 컨텍스트를 구성하는 방법으로는 전역 공간, eval() 함수, 함수 등이 있다.
    - 자동으로 생성하는 전역 공간을 제외하면 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것
  - 그 후 이를 콜 스택에 쌓았다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드를 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.



## 실행 컨텍스트는 어떻게 동작할까?

```javascript
// (1)
var first = 1;
function outer() {
    function inner() {
        console.log(first); // undefined
        var first = 9;
    }
    inner();  // (2)
    console.log(first)       // 1
}
outer(); // (3)
console.log(first);        // 1
```

- JS 코드가 실행되면, 전역 컨텍스트가 콜 스택에 담긴다.
  - 최상단의 공간은 코드 내부에서 별도 실행 명령 없이도 브라우저에서 자동 실행
  - 따라서, **JS 파일이 열리는 순간, 전역 컨텍스트가 활성화된다.**

- 현재까지는, 콜 스택에는 전역 컨텍스트만이 위치한 상황
  - 전역 컨텍스트와 관련된 코드를 순차로 실행하다가, `outer()` 함수를 호출한다.
  - JS 엔진은 `outer`에 대한 환경 정보를 수집한 뒤 outer 실행 컨텍스트를 생성하고, 콜 스택에 담는다.
  - 콜 스택의 최상단에 outer 실행 컨텍스트가 놓여진다.
    - 전역 컨텍스트와 관련된 코드의 실행은 일시중단되고, 대신 outer 함수 내부의 코드를 순차로 실행한다.
  - 이제 `outer`와 관련된 코드를 순차로 실행하다가, `inner()`함수를 호출하게 된다.
  - JS 엔진은 역시 `inner`에 대한 환경 정보를 수집하고서 inner 실행 컨텍스트를 생성하고, 콜 스택에 담는다.
    - 역시 outer 실행 컨텍스트와 관련된 코드의 실행은 일시중지되고, inner 함수 내부의 코드를 순차로 실행한다.
- 콜 스택에는 전역 컨텍스트 - outer - inner 순으로 쌓여있는 상황이 되었다!
  - inner 함수 내부에서 first라는 이름의 식별자에 9라는 값을 할당하는 것을 마지막으로, inner 함수의 실행은 종료된다.
    - 그 후, **inner 실행 컨텍스트가 콜 스택에서 제거된다.**
    - 이제 outer 실행 컨텍스트가 콜 스택의 최상단에 위치하게 되므로, inner()를 호출하며 중단되었던 지점(2) 다음부터 다시 실행을 이어나간다.
  - 변수 first의 값을 출력하는 것을 마지막으로, outer 함수의 실행도 종료된다.
    - outer 실행 컨텍스트가 콜 스택에서 제거된다.
    - **이제 콜 스택에는 전역 컨텍스트만이 남게 된다!**
  - 변수 first의 값을 출력하고 나면, 전역 공간에 실행할 코드가 없게 되어 전역 컨텍스트도 제거된다.
- 이제, **콜 스택에는 아무것도 남지 않게 된다.**



## 실행 컨텍스트 개체에는 무엇이 담길까?

- JS 엔진은 해당 컨텍스트에 관련된 코드를 실행하는 데 필요한 환경 정보를 수집해 실행 컨텍스트 객체에 저장한다.
  - 여기에는 아래의 정보들이 담긴다.
    - `VariableEnvironment`
      - 현재 컨텍스트 내의 식별자 대한 정보 + 외부 환경 정보.
      - 선언 시점의 `LexicalEnvironment`의 스냅샷으로, 변경 사항 반영 x
    - `LexicalEnvironment`
      - 처음에는 `VariableEnvironment`와 같지만, 변경 사항이 실시간 반영
    - `ThisBinding`
      - 식별자가 바라보는 대상 객체  

### VariableEnvironment

- `LexicalEnvironment`와 담기는 내용은 동일하지만, 최초 실행시의 스냅샷을 유지한다는 차이가 있다.
  - 실행 컨텍스트 생성시 `VariableEnvironment`에 정보를 먼저 담고, 이를 복사해 `LexicalEnvironment` 를 만들고, 그 이후에는 `LexicalEnvironment`를 사용한다.
- 내부에는 `environmentRecord`와 `outer-EnvironmentReference`를 포함하고 있다.



### LexicalEnvironment

- 내부에는 `environmentRecord`와 `outer-EnvironmentReference`를 포함하고 있다.
  - `environmentRecord`에는 현재 실행 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
    - 함수의 매개변수 식별자, 함수 자체, 변수의 식별자가 여기에 해당된다.
    - 해당 정보를 컨텍스트 내부 전체에서 순서대로 수집한다.
  - 이 때, 아직 **실행 컨텍스트와 관련된 코드는 실행되기 전인 상태이다.**
    - 그럼에도 JS 엔진은 이미 해당 환경 내 코드에서의 변수명들을 전부 알고 있는 상태가 된다.
    - 이러한 과정을 마치 JS 엔진이 식별자들을 최상단으로 끌어올린 다음 코드를 실행한다 라고 생각할 수 있는데, 여기서 **호이스팅**의 개념이 등장한다!

### 호이스팅

- 호이스팅?

  - 변수 정보 수집 과정을 이해하기 쉽게 하는 가상의 개념
    - JS 엔진이 실제로 끌어올리지는 않지만, 편의상 그렇게 간주함

  ```javascript
  function printer(x) {
    console.log(x);  // (1)
    var x;
    console.log(x); // (2)
    var x = 1;
    console.log(x);  // (3)
  }
  printer(3);
  ```

  - 위의 예시에서, 1~3번 각각에 어떤 값들이 출력될까?
    - 보통은 처음에 printer 함수를 호출하며 3을 인자로 전달했기에 1번에서는 3이,
    - 변수 x를 별도 초기화하는 과정 없이 선언만 했으니 2번에서는 undefined가,
    - 변수 x를 선언한 후 1이라는 값으로 초기화하였으니 3번에서는 1이 나올 것이라고 생각하게 된다.
  - 우선 알아둬야 할 점이 있다
    - 우선, 함수 printer를 호출하며 3이라는 값을 인자로 전달했다.
    - 함수 printer에는, x라는 매개변수를 가지고 있다.
    - 그렇기에, 함수에서의 다른 코드보다 매개변수 x에 3이라는 인자를 할당하는 과정이 선행된다.
    - `var x = 3`과 같이 먼저 선언하고, 할당해 초기화한 것으로 간주할 수 있다!
  - 호이스팅이 일어나는 과정을 따라가보자
    - `environmentRecord`는, 현재 실행할 컨텍스트의 대상 코드에 어떤 식별자가 있는지만 관심을 가진다.
      - 각 값에 할당되는 값에는 관심이 없다!
      - 그렇기 때문에 변수 호이스팅 시 **변수명만 끌어올리고, 값 할당 과정은 그대로 남겨둔다.**
      - 이에 맞게 위의 예시 코드를 호이스팅하고 나면 아래와 같이 바뀌게 된다.
        - 1번과 2번에서는 3이, 3번에서는 1이 출력된다!

  ```javascript
  function printer() {
      var x;
      var x;
      var x;
      
      x = 3;
      console.log(x); // (1)
      console.log(x); // (2)
      x = 1;
      console.log(x); // (3)
  }
  printer(3);
  ```



## 함수 선언문, 함수 표현식

### 선언문? 표현식?

- 표현식이란, **값으로 평가될 수 있는 선언문**을 말한다!
  - 표현식이 평가되면, 그를 통해서 새로운 값을 생성하거나, 메모리 영역에 있는 기본 값을 참조하게 된다.

- 선언문이란, **프로그램을 구성하는 기본 단위이자, 최소의 실행 단위**를 말한다!

  - 선언문은 여러 토큰으로 구성된다.
  - 토큰이란, **문법적으로 더 이상 나눌 수 없는 코드의 기본 요소**를 말한다.

  ```javascript
  // var car = 3 + 8 ; 이 모든 것들이 토큰이다
  var car = 3 + 8;
  ```

  

### 함수 선언문

- `function` 정의부만 존재하고, 별도의 할당 명령이 없다.
  - **반드시 함수명이 정의되어야 한다!**
- 선언문 전체를 호이스팅하기에, 전역공간에서 중복되어 선언되는 경우 의도하지 않은 오류가 발생할 수 있다.



### 함수 표현식

- 정의한 `function`을 **별도의 변수에 할당**하는 것이다.
  - 함수명을 반드시 정의할 필요가 없기에, **익명 함수 표현식**과 같은 사용이 가능하다.



### 호이스팅에서의 차이는?

- 함수 선언문은, **전체를 호이스팅한다.**
- 반면 함수 표현식에서는, 해당 함수를 할당하는 **변수의 선언부만 호이스팅한다.**



## 스코프 체인

### 스코프란?

- **식별자에 대한 유효범위**
- 함수 내부에서 함수를 중첩해 선언하는 경우
  - 내부 함수에서의 `outerEnvironmentReference`는 바로 바깥 함수에서의 `LexicalEnvironment`를 참조한다.
    - 각 함수 실행 컨텍스트의 outerEnvironmentReference는 오직 자신이 선언된 시점의 `LexicalEnvironment`만 참조하고 있는 연결 리스트 형태이기 때문이다!
    - 그렇기에 여러 스코프에서 **동일한 식별자로** 변수를 선언한 경우, **스코프 체인 상에서 가장 먼저 발견된 식별자에만** 접근 가능하다.
      - 이를 **변수 은닉화**라고 한다!
    - 전역 > A > B > C 와 같이 스코프 체인이 구성되어있다고 할 때
      - 전역 공간에서는 전역 스코프에서 생성된 변수에만 접근 가능하다.
      - 반면 B에서는 C 스코프 내부에서 생성된 변수에는 접근할 수 없지만, 전역, A, B 스코프 모두에 접근 가능하다.
  - 이렇게 계속 거슬러 올라가다 보면, 전역 컨텍스트의 `LexicalEnvironment`까지 만나게 된다.
  - 아래의 예시로 확인이 가능하다.
    - if 조건문 내에서 동일한 식별자를 선언했음에도, 출력되는 값이 다르다!
  
  ```javascript
  const hi = "hi";
  console.log(hi);       // hi
  if (true) {
      const hi = "bye";
      console.log(hi);     // bye
  }
  console.log(hi)     // hil
  ```
  
  

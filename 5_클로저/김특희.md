# 클로저

- 여러 정의에 따르면 클로저를 '현상'이나 '함수'로 보고있어, 맥락에 맞게 적절한 정의를 사용하여 작성했습니다.

### 클로저란

생명주기가 끝난 외부 함수의 환경을 참조할 수 있는 함수 또는 그러한 현상.

- 클로저를 통해 실행컨택스트가 종료된 외부함수에 접근할 수 있다.
- 자바스크립트 엔진의 규칙에 따르면, 특정 함수의 실행컨택스트가 종료되면 더 이상 해당 함수에 접근할 수 없게 된다.
  - 가비지 컬랙터에 의해 해당 함수가 메모리 내에서 삭제되기 때문.( = Lexical Environment가 삭제)
- 그러나 클로저가 발생하면, 실행컨택스트가 종료된 이후에도 가비지컬랙터는 외부함수의 Lexical Environment를 수집하지 않는다.

### 클로저 예시

```js
const outer = function () {
  let a = 1;
  let inner = function () {
    return ++a;
  };
  return inner;
};

let outer2 = outer();
console.log(outer2()); //2
console.log(outer2()); //3
```

- 변수 a가 전역에 선언된 것도 아닌데, 출력결과에 따르면 a의 값이 증가하고 있다.
- 변수 outer2를 통해 outer가 호출 => 실행 => 종료된다.
- 그러나 outer가 분명 종료되었음에도 outer의 변수 a가 기억되고 있다.
- 이유가 뭘까?

  - 이는 가비지 컬렉터의 동작 방식에 의해서 발생하는 현상이다.
  - **가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면, 그 변수를 수집하지 않는다.**
  - outer의 함수는 자신의 변수를 참조하는 inner라는 내부함수를 반환한다.
  - 따라서 inner함수는 외부에서 호출 가능한 상태다.
    - 예제에서는 outer2를 통해 호출되고있다.
  - 그런데 외부에서 호출 가능한 inner함수는 outer의 내부 변수 a를 참조한다.
  - **내부 변수 a는 호출 가능성이 있는 inner함수에 의해 참조되고 있으므로, outer의 실행컨택스트가 종료된 이후에도 가비지 컬렉팅되지 않고 메모리에 남아있다.**
  - 따라서 위의 예시에서 변수 a가 카운팅되는 것이다.

### 클로저와 가비지컬렉터

즉, 이처럼 외부함수가 종료되었음에도 외부함수의 내부변수가 메모리 상에서 지워지지 않고 사용가능한 현상을 클로저라 볼 수 있다. 이는 위의 예시와 같이 외부함수의 변수를 참조하는 내부함수가 호출가능한 상황일 때 발생한다. 그리고 이는 가비지 컬렉터의 동작방식과 관련된다.

- 가비지 컬렉터에 의하면, 어떤 값을 참조하는 변수가 하나라도 있다면 해당 값을 수집하지 않는다. 클로저 현상은 이러한 가비지 컬렉터의 규칙에 부합하기에 발생하는 것이다. 외부함수의 실행컨택스트가 종료된다할지라도 외부함수 내부의 변수를 참조하는 호출가능한 함수가 있기에, 해당 변수가 삭제되지 않는 것이다.

## 클로저 활용 사례

: 클로저는 구체적으로 어떠한 상황에서 활용될까.

### 1. 콜백함수 내부에서 외부 데이터 사용

- 예시

```js
let fruits = ['사과', '포도', '오렌지', '멜론'];

let alertFruitBuilder = function(fruit) {
  return function(){
  	alert("your choice is" + fruit);
  }
}

fruits.forEach(function(fruit) {
	let $li - document.createElement("li");
  	$li.innerText = fruit;
  	$li.addEventListener("click", alertFruitBuilder(fruit));
  	$ul.appendChild($li);
```

- alertFruitBuilder라는 익명함수를 반환하는 함수를 선언했다.

  - 해당 함수는 인자로 받을 fruit라는 외부 변수를 참조할 것이며 클로저가 발생할 것이다.

- alertFruitBuilder가 forEach메서드의 콜백함수 내부에서 활용되고 있다.

  - alertFruitBuilder 함수는 forEach 콜백함수 내부에 선언된 이벤트리스너의 콜백함수로 전달된다.
  - 동시에 외부함수인 forEach 콜백에 전달된 인자를 참조하고 있다.

- ForEach메서드를 통해 DOM에는 4개의 버튼들이 만들어지며, 각 버튼이 클릭될 때마다 alertFruitBuilder가 호출된다.
  - forEach메서드의 순회를 통한 각 단계의 fruit변수는 메서드의 실행 중 각기 생성된 버튼의 이벤트의 콜백(_alertFruitBuilder_)에 의해 참조된다. => **클로저**

위 예시 코드는 클로저를 활용하여 외부 데이터를 의도적으로 사용할 수 있음을 보여주는 것이다. 만약 정말 단순한 방법으로, 클로저를 활용하지 않았다면 배열의 각 요소들에 다이렉트로 접근하여 그 개수만큼 클릭이벤트를 생성하게 될 것이다. 이는 배열 내 요소의 개수가 많아지는 만큼 불편한 방법이 될 것이다.

### 2. 정보 은닉

: 정보 은닉이란 어떤 모듈의 내부 로직에 대한 노출을 제어하는 것이다. 외부에 의해 노출되어 변형되면 안되는 중요한 정보들을 숨길 수 있다. **클로저는 이러한 정보 은닉 기술에 활용될 수 있다.**

정보은닉과 클로저에 대한 게임 내 기본 캐릭터를 생성하는 예시를 들어보겠다.

#### 예시 1: 정보은닉 X

```js
let 기본캐릭터 = {
  레벨: 1,
  체력: 100,
  힘: this.레벨 + 10
  공격: function(){
    console.log(this.힘+"의 힘으로 때립니다!");
  }
}

기본캐릭터.공격(); // "11의 힘으로 때립니다!"
기본캐릭터.공격(); // "11의 힘으로 때립니다!"
```

해당 기본캐릭터 객체의 정보는 오픈되어있다. 만약 다음과 같이 기본캐릭터의 속성을 변경한다면 버그가 발생한다.

```js
기본캐릭터.힘 = 9999999999;

기본캐릭터.공격(); // "9999999999의 힘으로 때립니다!"
```

정보에 대한 접근을 막지 않는다면, 위와 같이 외부로부터 중요정보에 대한 조작이 가능하다. **내부에서 중요한 정보에 대해 접근가능하게 하되, 외부로부터는 은닉해야할 필요성이 있다. 클로저를 통해 이를 제어할 수 있다.**

#### 예시2: 정보은닉과 클로저

```js
let 기본캐릭터() {
  let 레벨 = 1;
  let 체력 = 100;
  let 힘 = 레벨 + 10;

  return{
  	공격: function() {
      console.log(힘+" 힘으로 때립니다!");
    }
  }
}

let 마이캐릭터 = 기본캐릭터();

```

- 이번에는 함수를 통해 객체를 생성했다.

- 레벨, 체력, 힘은 return하지 않음으로써 정보를 은닉한다.
  - 이제 해당 정보를 외부에서 조작할 수 없게 되었다.
- 기본캐릭터 함수가 반환하는 것은 '공격'이라는 메서드다.
  - 해당 메서드에서는 클로저가 발생한다.
  - '힘'이라는 외부 함수의 정보에 대해 접근할 수 있는 권한이 생겼다 볼 수 있다.

결과

```js
console.log(마이캐릭터.힘); //undefined
마이캐릭터.공격(); // "11의 힘으로 때립니다!"
```

: 이제 외부에서 중요정보에 대해 접근할 수 없게 되었고, 내부 메서드에서만 중요정보에 접근할 수 있게 되었다!

: 객체의 중요 정보에 대해서, 객체 메서드에서는 접근가능하게 하되 외부로부터는 은닉해야할 필요성이 있다. 그리고 클로저를 통해 이를 제어할 수 있다.

### 3. 부분 적용 함수와 클로저

- 부분 적용 함수는 인자와 관련된 함수이다.
  - 부분 적용 함수를 활용하면 두 단계에 거쳐 인자를 받을 수 있다.
  - 부분적으로 인자를 받아 놓고, 후에 전달될 인자를 추가하면 그때 함수를 실행할 수 있다.
  - 부분 적용 함수의 핵심은 미리 받아놓은 인자가 **'기억'** 되어야한다는 것이다.
    - 그리고 클로저를 통해 이를 구현할 수 있다.

**예시 :** 본문의 예시를 가져왔다.
클로저가 부분적용함수에서 어떻게 활용되는지만을 설명하고자 한다

```js

let partial = function() {
	let originalPartialArgs = arguments;
  	let func = originalPartialArgs[0];
  if( typeof func !== "function") {
    	throw new Error("첫 번째 인자가 함수가 아닙니다!");

  }
  return function() {
  	let partialArgs = Array.prototype.slice.call(originalPartialArgs, 1);
    let restArgs = Array.prototype.slice.call(arguments);
    return func.apply(this, partialArgs.concat(restArgs));
  }
}


let add = fucntion() {
	var result = 0;
  for (let i =0; i < arguments.length; i++) {
  	result += arguments[i];
  }
  return result;
}


let addPartial = partial(add, 1,2,3,4,5); // 부분적용함수 선언
console.log(addPartial(6,7,8,9,10)); // 추가 인수 기입 & 결과 = 55


```

- partial 함수는 클로저를 사용한다.
  - 리턴되는 내부익명함수에서 외부함수의 변수를 참조하며 클로저가 발생한다.
  - 참조되는 과정에서 부분적용함수의 핵심인 먼저 전달받은 인수가 **기억**된다.
  - 이는 이후 로직에 따라, 추가 전달받은 인수와 합치게 되는 과정에 사용된다.

### 4. 커링 함수와 클로저

:커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만을 받는 함수로 쪼개 순차적으로 호출시키는 함수를 의미한다.

**예시**

```js
const curry = function (func) {
  return function (a) {
    return function (b) {
      return func(a, b); // 클로저
    };
  };
};

const getMax = curry(Math.max)(10); // (1)
console.log(getMax(20)); // (2)  출력: 20
console.log(getMax(5)); // (3)  출력: 5

const getMin = curry(Math.min)(30)(100); // return 30
```

위의 예시와 같이 커링함수를 쓰면 인수를 각각 받을 수 있다.
**또한 커리 함수에서 클로저가 발생하는 것을 볼 수 있다.**
해당 예시는 (1)에서 인자 a로 전달된 10이 코드(2),(3)에서도 그대로 참조되고 있음을 보여준다. 이는 커리함수의 구조 상 가장 하위 스코프에서 리턴이 발생할 때까지 상위 스코프의 변수들을 참조하기 때문이다.

커링함수는 다음과 같이 화살표함수로 간단하게 구현될 수도 있다.

```js
let curry = (func) => (a) => (b) => (c) => (d) => (e) => func(a, b, c, d, e);

let getMin = curry(Math.min)(1)(2)(3)(4)(5); // return 1
```

## 정리

- 클로저란 실행컨택스트가 종료된 이후에도 해당 함수의 변수가 메모리 상에서 삭제되지 않고, 참조가능한 현상을 의미한다.

  - 혹은 실행 컨택스트가 종료된 함수의 변수를 참조할 수 있는 함수로도 정의될 수 있다.

- 클로저라는 현상은 참조가능한 특정값을 수집하지 않는 가비지컬렉터의 동작방식과 관련된다.

  - 즉 사용가능한 다른 값에 의해 참조받는 값은 실행컨택스트가 종료되더라도 가비지 컬렉터에 의해 수집되지 않는 것이다.

- 클로저는 정보 은닉, 커링 함수, 부분 적용 함수 등에서 활용된다.

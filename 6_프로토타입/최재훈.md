# 코어 자바스크립트 Note

## 06. 프로토타입

- 클래스 기반 언어에서는 '상속'을 사용하지만,
- 프로토타입 기반 언어에서는 어떤 객체를 '원형'으로 삼고, 이를 복제(참조) 함으로써 상속과 비슷한 효과를 얻는다.

### 01. 프로토타입의 개념 이해

```js
var instance = new Constructor();

어떤 생성자 함수를 new 연산자와 함께 호출
'Constructor'에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성.
instance에는 __proto__ 라는 프로퍼티가 자동으로 부여,
이 프로퍼티는 Constructor의 prototype이라는 프로퍼티 참조.
```

prototype은 객체

이를 참조하는 ** proto ** 역시 객체.

prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장.

인스턴스에도 숨겨진 프로퍼티인 ** proto ** 를 통해 이러한 메서드들에 접근할 수 있게 함.

```js
예제 6-1. Person.prototype
var Person = function (name){
    this._name = name;
};

Person.prototype.getName = function() {
    return this._name;
}

Person 인스턴스는 __proto__ 프로퍼티를 통해 getName을 호출할 수 있다.

var suzi = new Person('Suzi');
suzi.__proto__.getName(); // undefined

instance의 __proto__가 Constructor의 prototype 프로퍼티를 참조, 결국 같은 객체를 바라봄.

Person.prototye === suzi.__proto__ // true
```

- 메서드 호출 결과로 왜 undefined가 나왔나?

  - undefined가 나왔다는 것은 이 변수가 '호출할 수 있는 함수'에 해당한다는 것을 의미.
  - 실행할 수 없는, 함수가 아닌 다른 데이터 타입이었다면 TypeError가 발생.
    - 값이 에러가 아닌 다른 값이 나왔으니까 getName이 실제로 실행, 이로부터 getName이 함수라는 것이 입증.

- 함수 내부에서는 어떤 값을 반환하나?

  - this.name 값을 리턴하는 내용
  - 문제는 this에 바인딩된 대상이 잘못 지정됐다는 것.

- 어떤 함수를 '메서드로서' 호출할 때는 메서드명 바로 앞의 객체가 this가 된다.

  - 즉, thomas.\_ _ proto _ _.getName()에서 get Name 함수 내부에서의 this는 thomas가 아니라, thomas._ _ proto _ \_ 라는 객체가 된다.
  - '찾고자 하는 식별자가 정의돼 있지 않다면, Error 대신 undefined를 반환함'

- 그렇다면, '** proto**' 객체에 name 프로퍼티가 있다면?

```js
var suzi = new Person('Suzi');
suzi.__proto__._name = 'Suzi__proto__';
suzi.__proto__.getName(); // Suzi__proto__
잘 출력된다. 관건은 'this'임
__proto__ 없이 인스턴스에서 곧바로 메서드를 쓰는 것.

var suzi = new Person('Suzi', 28);
suzi.getName(); // Suzi

__proto__를 빼면, this는 instance가 되는 게 맞지만, 이대로 메서드가 호출되고 원하는 값이 나온다?
Why? --> __proto__가 '생략 가능'한 프로퍼티임.

__proto__를 생략하지 않으면, this는 suzi.__proto__를 가리킴.
생략하면, suzi를 가리킴.

suzi.__proto__에 있는 메서드인 getName을 실행하지만 this는 suzi를 바라볼 수 있게 됨.
```

#### new 연산자로 Constructor를 호출하면 instance 생성, 이 instance의 생략 가능한 프로퍼티인 '** proto**' 는 Constructor의 prototype을 참조한다.

즉, JS는 자동으로 함수에 객체인 prototype 프로퍼티를 생성, 해당 함수를 생성자 함수로 사용할 경우,
new 연산자와 함께 함수를 호출할 경우, 그로부터 생성된 인스턴스에는 숨겨진 프로퍼티인 ** proto**가 자동 생성되고, 이 프로퍼티는 생성자 함수의 prototpye 프로퍼티를 참조한다.

** proto** 프로퍼티는 생략 가능
즉, **생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면, 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근 가능**

```js
var Constructor = function (name) {
  this.name = name;
};
Constructor.prototype.method1 = function () {};
Constructor.prototype.property1 = "Constructor Prototype Orperty";

var instance = new Constructor("Instance");
console.dir(Constructor);
console.dir(instance);
```

- 출력 결과를 보면 내부에는 옅은 색의 argumens, caller, legnth, name, prototype, **proto** 등의 프로퍼티들이 있다.

  - 다시 prototype을 열어보면 예제에서 추가한 method1, property1 등의 값이 짙은 색으로 보이고, constructor, **proto** 등이 옅은 색으로 보인다.
    > 이런 색상의 차이는? { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따른다.
    > 짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, 옅은색은 innumerable, 즉 열거할 수 없는 프로퍼티임을 의미한다.
    > for in 등으로 객체의 프로퍼티 전체에 접근하고자 할 때 접근 가능 여부를 색상으로 구분지어 표기하는 것이다.

- 다음 출력으로는 instance의 디렉터리 구조를 출력하는데, 이 때는 Constructor가 나오고 있다

  - 어떤 생성자 함수의 인스턴스는 해당 생성자 함수의 이름을 표기함으로써 해당 함수의 인스턴스임을 표기하고 있다.
  - Constructor를 열어보면 name 프로퍼티가 짙은 색으로 보이고, **proto** 프로퍼티가 옅은 색으로 보인다.

- 생성자 함수와 prototype, 인스턴스 사이의 관계?!
  - Array를 new 연산자와 함께 호출해서 인스턴스를 생성하든, 배열 리터럴을 생성하든, instance인 [1, 2]가 만들어진다.
  - 이 인스턴스의 **proto**은 Array.prototype을 참조하는데, **proto**가 생략 가능하도록 설계돼 있기 떄문에 인스턴스가 push, pop, forEach 등의 메서드를 마치 자신의 것처럼 호출 가능
  - Array의 prototype 프로퍼티 내부에 있지 않은 from, isArray 등의 메서드들은 인스턴스가 직접 호출할 수 없을 것이다.
    - 이들은 Array 생성자 함수에서 직접 접근해야 실행이 가능하다.
    ```js
    var arr = [1, 2];
    arr.forEach(function () {}); // (0)
    Array.isArray(arr); // (0) true
    arr.isArray(); // (X) TypeError: arr.isArray is not a function
    ```

### 02. constructor 프로퍼티

- prototype 객체를 참조하는 ** proto ** 를 생략하면 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 마치 자신의 것처럼 사용할 수 있다.
  - 만약 인스턴스가 동일한 이름의 프로퍼티 || 메서드를 갖고 있다면?

```js
var Person = function (name) {
  this.name = name;
};
Person.prototype.getName = function () {
  return this.name;
};

var iu = new Person("지금");
iu.getName = function () {
  return "바로" + this.name;
};
console.log(iu.getName()); // 바로 지금
----
iu.__proto__.getName이 아닌 iu 객체에 있는 getName 메서드가 호출됐다.
이 현상이 바로 '오버라이드' 라는 현상.
```

- 메서드 위에 메서드를 덮어 씌웠다는 표현
- 원본을 제거하고 다른 대상으로 교체 XX
- 원본이 그대로 있는 상태에서 다른 대상을 그 위에 얹는 느낌 OO

- 엔진이 getName이라는 메서드를 찾는 방식은 가장 가까운 대상인 자신의 프로퍼티를 검색하고 없으면 그 다음으로 가까운 대상인 ** proto **를 검색하는 순서로

- 즉, ** proto ** 에 있는 메서드는 자신에게 있는 메서드보다 검색 순서에서 밀려 호출되지 않은 것.

  - 교체하는 형태라면 원본에는 접근할 수 없는 형태가 되겠지만
  - 얹는 형태라면 원본이 아래에 유지되고 있으니 원본에 접근할 수 있는 방법도 있다.

- 그렇다면 메서드 오버라이딩이 이뤄져 있는 상황에서 prototype에 있는 메서드에 접근하려면 어떻게 해야되나?

```js
console.log(iu.__proto__.getName()); // undefined
```

- 이 경우는, this가 prototype 객체(iu.** proto **)를 가리키는데 prototype 상에는 name 프로퍼티가 없기 때문에 undefined가 출력됐다.

- 만약 prtotype에 name 프로퍼티가 있다면 그 값을 출력할 것.

```js
Person.prototype.name = '이지금';
console.log(iu.__proto__.getName()); // 이지금

원하는 메서드가 호출되고 있다.
this가 prototype을 바라보고 있는데, 이걸 인스턴스를 바라보도록 바꿔주면 된다.

console.log(iu.__proto__getName.call(iu)); // 지금
```

#### 02-03. 객체 전용 메서드의 예외사항

Object.prototype이 여타의 참조형 데이터뿐 아니라 기본형 데이터조차 ** proto **에 반복 접근함으로써 도달할 수 있는 최상위 존재이다.

반대로, Object.prototype에는 어떤 데이터에서도 활용할 수 있는 범용적인 메서드들만 있다.
ex: toString, hasOwnProperty, valueOf, isPrototypeOf

```js
'프로토타입 체인상 가장 마지막에는 언제나 Object.prototype이 있다' ??
예외적으로, object.create를 이용하면, Object.prototype의 메서드에 접근할 수 없는 경우가 있다.
Object.create(null)은 __proto__가 없는 객체를 생성한다.
```

#### 02-04. 다중 프로토타입 체인

자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인이 1단계(객체)이거나 2단계(나머지)로 끝나는 경우만 있었지만

사용자가 새롭게 만드는 경우에는 그 이상도 '얼마든지' 가능하다.

### How?

```js
___proto__가 가리키는 대상, 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보게끔 한다.
```

### 정리

- 어떤 생성자 함수를 new 연산자와 함께 호출하면 Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성되는데, 이 인스턴스에는 **proto **라는 , Constructor의 prototype 프로퍼티를 참조하는 프로퍼티가 자동으로 부여된다.

- **proto **는 생략 가능한 속성이라서, 인스턴스는 Constructor.prototype의 메서드를 마치 자신의 메서드인 것처럼 호출할 수 있다.

- Constructor.prototype에는 constructor라는 프로퍼티가 있는데, 이는 다시 생성자 함수 자신을 가리키고

  - 이 프로퍼티는 인스턴스가 자신의 생성자 함수가 무엇인지를 알고자할 때 필요한 수단이다.

- **proto **방향을 계속 찾아나가면 최종적으로 Object.prototype에 도달하고

  - 이런 식으로 **proto **안에 다시 **proto **를 찾아가는 과정을 프로토타입 체이닝이라고 하며,
  - 이 프로토타입 체이닝을 통해 각 프로토타입 메서드를 자신의 것처럼 호출할 수 있다

- 이떄 접근 방식은 자신으로부터 가장 가까운 대상부터 점차 먼 대상으로 나아가며, 원하는 값을 찾으면 검색을 중단

- Object.prototype에는 모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만이 존재하고, 객체 전용 메서드는 여느 데이터 타입과 달리 Object 생성자 함수에 스태틱하게 담겨있다.
